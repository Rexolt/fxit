<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>f(xit) Pro - Advanced Graphing Engine</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --bg-app: #0f1115;
            --bg-panel: #181b21;
            --bg-input: #232730;
            --border: #2f3542;
            --accent: #00d2d3;
            --accent-hover: #01a3a4;
            --text-main: #dfe6e9;
            --text-muted: #b2bec3;
            --success: #00b894;
            --warning: #fdcb6e;
            --danger: #ff7675;
            --radius: 6px;
            --shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        * { box-sizing: border-box; outline: none; user-select: none; }
        
        body {
            margin: 0;
            background: var(--bg-app);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        aside {
            width: 380px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 4px 0 20px rgba(0,0,0,0.5);
        }

        .brand {
            padding: 20px;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(to right, rgba(0,210,211,0.1), transparent);
        }

        .function-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .function-item {
            background: var(--bg-input);
            border-radius: var(--radius);
            padding: 12px;
            margin-bottom: 12px;
            border-left: 4px solid transparent;
            transition: all 0.2s;
            position: relative;
        }

        .function-item.active-selection {
            background: #2d3436;
            box-shadow: 0 0 0 1px var(--accent);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .f-label {
            font-family: 'JetBrains Mono', monospace;
            font-weight: bold;
            color: var(--text-muted);
            cursor: pointer;
        }

        input[type="text"] {
            background: transparent;
            border: none;
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            width: 100%;
            border-bottom: 1px solid var(--border);
            padding: 4px;
            transition: border 0.2s;
        }

        input[type="text"]:focus { border-bottom-color: var(--accent); }

        .controls {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 5px;
        }

        .btn-icon {
            background: rgba(255,255,255,0.05);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .btn-icon:hover { color: var(--text-main); background: rgba(255,255,255,0.15); }
        .btn-icon.danger:hover { color: var(--danger); background: rgba(255,118,117,0.1); }

        .add-btn {
            background: var(--bg-input);
            border: 1px dashed var(--border);
            color: var(--text-muted);
            padding: 15px;
            margin: 15px;
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            font-weight: 600;
        }
        .add-btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0,210,211,0.05); }

        .analysis-panel {
            height: 35%;
            border-top: 1px solid var(--border);
            background: #131519;
            display: flex;
            flex-direction: column;
        }
        .analysis-header {
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
        }
        .analysis-content {
            padding: 15px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            flex: 1;
        }
        .result-row { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 6px; 
            border-bottom: 1px solid rgba(255,255,255,0.05); 
            padding-bottom: 4px;
        }
        .result-key { color: var(--text-muted); }
        .result-val { color: var(--text-main); font-weight: bold; }

        main {
            flex: 1;
            position: relative;
            background: var(--bg-app);
            cursor: crosshair;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .toolbar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 100;
        }

        .toolbar {
            background: rgba(24, 27, 33, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 15px;
            border-radius: 50px;
            display: flex;
            gap: 15px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .tool-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            padding: 5px;
            border-radius: 5px;
        }

        .tool-btn:hover { color: #fff; transform: translateY(-2px); }
        .tool-btn.active { color: var(--accent); text-shadow: 0 0 10px rgba(0,210,211,0.5); }
        
        .tool-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 6px 10px;
            font-size: 0.75rem;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            font-family: 'Inter', sans-serif;
        }
        .tool-btn:hover::after { opacity: 1; }

        .separator { width: 1px; background: #444; height: 24px; align-self: center; }

        .status-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            pointer-events: none;
            color: var(--accent);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(4px);
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-window {
            background: var(--bg-panel);
            width: 500px;
            max-height: 80vh;
            border-radius: 10px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
        }
        .modal-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: var(--text-main);
        }
        .modal-body {
            padding: 0;
            overflow-y: auto;
        }
        table.data-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }
        .data-table th, .data-table td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .data-table th { background: rgba(255,255,255,0.05); color: var(--accent); position: sticky; top: 0; }
        .data-table tr:hover { background: rgba(255,255,255,0.02); }

        .close-btn { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1.2rem; }
        .close-btn:hover { color: var(--danger); }

        .loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent);
            display: none;
            pointer-events: none;
        }

    </style>
</head>
<body>

<aside>
    <div class="brand">
        <i class="fas fa-wave-square"></i> f(xit) Pro
    </div>
    
    <div class="function-list" id="functionContainer">
        </div>

    <div class="add-btn" id="btnAddFunc">
        <i class="fas fa-plus"></i> Új függvény hozzáadása
    </div>

    <div class="analysis-panel" id="analysisPanel">
        <div class="analysis-header">
            <span>Eredmények</span>
            <i class="fas fa-terminal"></i>
        </div>
        <div class="analysis-content" id="analysisContent">
            <div style="color: #666; font-style: italic; text-align: center; margin-top: 20px;">
                Válassz egy eszközt a fenti sávból, vagy mozgasd az egeret a görbéken.
            </div>
        </div>
    </div>
</aside>

<main>
    <div class="toolbar-container">
        <div class="toolbar">
            <button class="tool-btn" id="btnHome" data-tooltip="Nézet visszaállítása"><i class="fas fa-expand"></i></button>
            <button class="tool-btn" id="btnSnapshot" data-tooltip="Képmentés (PNG)"><i class="fas fa-camera"></i></button>
            <button class="tool-btn" id="btnTable" data-tooltip="Értéktáblázat"><i class="fas fa-table"></i></button>
            <div class="separator"></div>
            <button class="tool-btn" id="btnRoots" data-tooltip="Zérushelyek"><i class="fas fa-bullseye"></i></button>
            <button class="tool-btn" id="btnExtrema" data-tooltip="Szélsőértékek"><i class="fas fa-chart-line"></i></button>
            <button class="tool-btn" id="btnIntersect" data-tooltip="Metszéspont (f=g)"><i class="fas fa-xmark"></i></button>
            <div class="separator"></div>
            <button class="tool-btn" id="btnIntegral" data-tooltip="Terület (Integrál)"><i class="fas fa-draw-polygon"></i></button>
            <button class="tool-btn" id="btnTangent" data-tooltip="Érintő"><i class="fas fa-arrow-trend-up"></i></button>
            <button class="tool-btn" id="btnDerivPlot" data-tooltip="Derivált Görbe (f')"><i class="fas fa-bezier-curve"></i></button>
            <button class="tool-btn" id="btnAutoFit" data-tooltip="Auto Focus (Y)"><i class="fas fa-compress-arrows-alt"></i></button>
        </div>
    </div>

    <canvas id="graphCanvas"></canvas>
    <div class="status-bar" id="coords">x: 0.00 | y: 0.00</div>
    <div class="loader" id="loader"><i class="fas fa-spinner fa-spin fa-2x"></i></div>
</main>

<div class="modal-overlay" id="tableModal">
    <div class="modal-window">
        <div class="modal-header">
            <span><i class="fas fa-table"></i> Értéktáblázat</span>
            <button class="close-btn" onclick="document.getElementById('tableModal').style.display='none'"><i class="fas fa-times"></i></button>
        </div>
        <div class="modal-body">
            <table class="data-table" id="dataTableContent">
                <thead><tr><th>X</th><th>Y = f(x)</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>

<script>
class MathCore {
    static parse(expression) {
        try {
            let safeExpr = expression.toLowerCase()
                .replace(/\s+/g, '')
                .replace(/\^/g, '**')
                .replace(/([0-9\)])\(/g, '$1*(')
                .replace(/([0-9])([a-z])/g, '$1*$2')
                .replace(/(sin|cos|tan|sqrt|log|abs|exp|asin|acos|atan|sinh|cosh|tanh|pi|e)/g, 'Math.$1');
            
            return new Function('x', `return ${safeExpr};`);
        } catch (e) {
            return null;
        }
    }

    static evaluate(func, x) {
        try { return func(x); } catch { return NaN; }
    }

    static findRoots(func, start, end, step = 0.05) {
        let roots = [];
        let prevY = this.evaluate(func, start);
        for(let x = start; x <= end; x += step) {
            let y = this.evaluate(func, x);
            if(Math.sign(y) !== Math.sign(prevY) && !isNaN(y) && !isNaN(prevY)) {
                let r = this.binarySearchRoot(func, x - step, x);
                if(r !== null) roots.push(r);
            }
            prevY = y;
        }
        return roots;
    }

    static binarySearchRoot(func, left, right, iter = 20) {
        let mid = (left + right) / 2;
        for(let i=0; i<iter; i++) {
            mid = (left + right) / 2;
            let yMid = func(mid);
            if(yMid === 0) return mid;
            if(Math.sign(yMid) === Math.sign(func(left))) left = mid;
            else right = mid;
        }
        return mid;
    }

    static derivative(func, x) {
        const h = 0.00001;
        return (func(x + h) - func(x - h)) / (2 * h);
    }

    static findExtrema(func, start, end) {
        const dFunc = (x) => this.derivative(func, x);
        const criticalPoints = this.findRoots(dFunc, start, end, 0.1);
        return criticalPoints.map(x => ({ 
            x: x, 
            y: func(x), 
            type: this.derivative(dFunc, x) > 0 ? 'Min' : 'Max' 
        }));
    }

    static integrate(func, a, b, n = 1000) {
        const h = (b - a) / n;
        let sum = 0.5 * (func(a) + func(b));
        for (let i = 1; i < n; i++) sum += func(a + i * h);
        return sum * h;
    }

    static findIntersections(f1, f2, start, end) {
        const diffFunc = (x) => f1(x) - f2(x);
        const roots = this.findRoots(diffFunc, start, end, 0.1);
        return roots.map(x => ({ x: x, y: f1(x) }));
    }
}

/**
 * 2. GRAPH ENGINE
 */
class GraphEngine {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        
        this.camera = { x: 0, y: 0, zoom: 50 };
        this.functions = [];
        this.markers = [];
        this.overlayFunc = null;
        this.fillArea = null;
        
        this.selectedFuncId = null;
        this.mousePos = { x: 0, y: 0 };
        this.isTraceMode = true;

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInteraction();
        this.requestRender();
    }

    resize() {
        this.width = this.canvas.width = this.canvas.parentElement.clientWidth;
        this.height = this.canvas.height = this.canvas.parentElement.clientHeight;
        this.requestRender();
    }

    toScreenX(wx) { return (wx - this.camera.x) * this.camera.zoom + this.width / 2; }
    toScreenY(wy) { return this.height / 2 - (wy - this.camera.y) * this.camera.zoom; }
    toWorldX(sx) { return (sx - this.width / 2) / this.camera.zoom + this.camera.x; }
    toWorldY(sy) { return (this.height / 2 - sy) / this.camera.zoom + this.camera.y; }

    setupInteraction() {
        let isDragging = false;
        let lastX, lastY;

        this.canvas.addEventListener('mousedown', e => { 
            isDragging = true; 
            lastX = e.clientX; 
            lastY = e.clientY; 
            this.canvas.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => { 
            isDragging = false; 
            this.canvas.style.cursor = 'crosshair';
        });

        this.canvas.addEventListener('mousemove', e => {
            const rect = this.canvas.getBoundingClientRect();
            this.mousePos.x = e.clientX - rect.left;
            this.mousePos.y = e.clientY - rect.top;

            if (isDragging) {
                const dx = (e.clientX - lastX) / this.camera.zoom;
                const dy = (e.clientY - lastY) / this.camera.zoom;
                this.camera.x -= dx;
                this.camera.y += dy;
                lastX = e.clientX; 
                lastY = e.clientY;
            }
            this.requestRender();
        });

        this.canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const zoomFactor = Math.exp(-e.deltaY * zoomSensitivity);
            
            const wx = this.toWorldX(this.mousePos.x);
            const wy = this.toWorldY(this.mousePos.y);

            this.camera.zoom = Math.max(5, Math.min(5000, this.camera.zoom * zoomFactor));
            
            this.camera.x = wx - (this.mousePos.x - this.width/2) / this.camera.zoom;
            this.camera.y = wy - (this.height/2 - this.mousePos.y) / this.camera.zoom;

            this.requestRender();
        }, { passive: false });
    }

    render() {
        this.ctx.fillStyle = '#0f1115';
        this.ctx.fillRect(0, 0, this.width, this.height);

        this.drawGrid();

        if(this.fillArea) {
            this.drawArea(this.fillArea);
        }

        this.functions.forEach(f => {
            if (!f.visible || !f.func) return;
            this.drawCurve(f.func, f.color, f.id === this.selectedFuncId ? 3 : 2);
        });

        if(this.overlayFunc) {
            this.drawCurve(this.overlayFunc.func, '#fdcb6e', 2, [5, 5]);
        }

        this.drawMarkers();

        this.renderSmartTrace();
    }

    drawGrid() {
        const step = this.getGridStep();
        const ctx = this.ctx;
        
        ctx.lineWidth = 1;
        ctx.font = '11px JetBrains Mono';
        ctx.fillStyle = '#666';

        const left = this.toWorldX(0);
        const right = this.toWorldX(this.width);
        const startX = Math.floor(left / step) * step;
        
        for (let x = startX; x <= right; x += step) {
            const sx = this.toScreenX(x);
            ctx.beginPath();
            ctx.strokeStyle = Math.abs(x) < step/100 ? '#7f8c8d' : '#2f3542';
            ctx.lineWidth = Math.abs(x) < step/100 ? 2 : 1;
            ctx.moveTo(sx, 0); ctx.lineTo(sx, this.height);
            ctx.stroke();
            if(Math.abs(x) > step/100) ctx.fillText(parseFloat(x.toPrecision(4)), sx + 4, this.toScreenY(0) + 12);
        }

        const bottom = this.toWorldY(this.height);
        const top = this.toWorldY(0);
        const startY = Math.floor(bottom / step) * step;

        for (let y = startY; y <= top; y += step) {
            const sy = this.toScreenY(y);
            ctx.beginPath();
            ctx.strokeStyle = Math.abs(y) < step/100 ? '#7f8c8d' : '#2f3542';
            ctx.lineWidth = Math.abs(y) < step/100 ? 2 : 1;
            ctx.moveTo(0, sy); ctx.lineTo(this.width, sy);
            ctx.stroke();
            if(Math.abs(y) > step/100) ctx.fillText(parseFloat(y.toPrecision(4)), this.toScreenX(0) + 6, sy - 4);
        }
    }

    getGridStep() {
        const targetPx = 80;
        const rawStep = targetPx / this.camera.zoom;
        const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
        const res = rawStep / mag;
        if(res > 5) return 10 * mag;
        if(res > 2) return 5 * mag;
        return mag;
    }

    drawCurve(func, color, width, dash = []) {
        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = width;
        this.ctx.setLineDash(dash);

        let first = true;
        const pxStep = 2;
        
        for (let px = 0; px <= this.width; px += pxStep) {
            const wx = this.toWorldX(px);
            const wy = MathCore.evaluate(func, wx);
            const sy = this.toScreenY(wy);

            if (isNaN(wy) || sy < -this.height || sy > this.height * 2) {
                first = true;
            } else {
                if (first) this.ctx.moveTo(px, sy);
                else this.ctx.lineTo(px, sy);
                first = false;
            }
        }
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }

    drawArea(area) {
        const { func, a, b, color } = area;
        const ctx = this.ctx;
        ctx.beginPath();
        ctx.fillStyle = color + "33";
        
        let startX = Math.max(a, this.toWorldX(0));
        let endX = Math.min(b, this.toWorldX(this.width));

        const step = (endX - startX) / Math.min(400, (endX-startX)*this.camera.zoom);
        
        ctx.moveTo(this.toScreenX(startX), this.toScreenY(0));
        for(let x = startX; x <= endX; x += step) {
            ctx.lineTo(this.toScreenX(x), this.toScreenY(func(x)));
        }
        ctx.lineTo(this.toScreenX(endX), this.toScreenY(0));
        ctx.fill();
    }

    drawMarkers() {
        this.markers.forEach(m => {
            const sx = this.toScreenX(m.x);
            const sy = this.toScreenY(m.y);
            
            this.ctx.beginPath();
            this.ctx.fillStyle = m.color || '#fff';
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = m.color;
            this.ctx.arc(sx, sy, 5, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;

            if(m.slope !== undefined) {
                const len = 1000;
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                const x1 = m.x - 10; const y1 = m.y - m.slope * 10;
                const x2 = m.x + 10; const y2 = m.y + m.slope * 10;
                this.ctx.moveTo(this.toScreenX(x1), this.toScreenY(y1));
                this.ctx.lineTo(this.toScreenX(x2), this.toScreenY(y2));
                this.ctx.stroke();
            }
        });
    }

    renderSmartTrace() {
        const wx = this.toWorldX(this.mousePos.x);
        const wy = this.toWorldY(this.mousePos.y);
        let statusText = `x: ${wx.toFixed(2)} | y: ${wy.toFixed(2)}`;
        let activeFunc = this.functions.find(f => f.id === this.selectedFuncId && f.visible);

        if(!activeFunc && this.functions.length > 0) activeFunc = this.functions.find(f => f.visible);

        if (this.isTraceMode && activeFunc && activeFunc.func) {
            const fy = MathCore.evaluate(activeFunc.func, wx);
            const screenFY = this.toScreenY(fy);

            this.ctx.beginPath();
            this.ctx.fillStyle = activeFunc.color;
            this.ctx.arc(this.mousePos.x, screenFY, 6, 0, Math.PI*2);
            this.ctx.fill();

            this.ctx.beginPath();
            this.ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            this.ctx.setLineDash([4, 4]);
            this.ctx.moveTo(this.mousePos.x, screenFY);
            this.ctx.lineTo(this.mousePos.x, this.toScreenY(0));
            this.ctx.moveTo(this.mousePos.x, screenFY);
            this.ctx.lineTo(this.toScreenX(0), screenFY);
            this.ctx.stroke();
            this.ctx.setLineDash([]);

            statusText = `x: ${wx.toFixed(3)} | f(x): ${fy.toFixed(3)}`;
        }

        document.getElementById('coords').innerHTML = statusText;
    }

    requestRender() {
        requestAnimationFrame(() => this.render());
    }

    addFunction(expr, color = '#00d2d3') {
        const func = MathCore.parse(expr);
        const id = Date.now();
        this.functions.push({ id, expr, func, color, visible: true });
        this.selectedFuncId = id;
        this.requestRender();
        return id;
    }

    exportImage() {
        const link = document.createElement('a');
        link.download = `fxit_graph_${Date.now()}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
    }

    autoFocusY() {
        if(this.functions.length === 0) return;
        const start = this.toWorldX(0);
        const end = this.toWorldX(this.width);
        let min = Infinity, max = -Infinity;
        
        const f = this.functions.find(x => x.id === this.selectedFuncId) || this.functions[0];
        
        for(let x = start; x <= end; x += (end-start)/50) {
            const val = MathCore.evaluate(f.func, x);
            if(!isNaN(val)) {
                if(val < min) min = val;
                if(val > max) max = val;
            }
        }
        
        if(min !== Infinity) {
            const center = (min + max) / 2;
            const range = max - min;
            const newRange = range < 0.1 ? 2 : range * 1.5;
            
            this.camera.y = center;
            this.camera.zoom = this.height / newRange;
            this.requestRender();
        }
    }
}

/**
 * 3. UI CONTROLLER
 */
const engine = new GraphEngine('graphCanvas');
const uiList = document.getElementById('functionContainer');
const analysisOut = document.getElementById('analysisContent');
const colors = ['#00d2d3', '#ff9f43', '#5f27cd', '#ff6b6b', '#48dbfb', '#1dd1a1'];
let colorIdx = 0;

function createFunctionUI(id, expr, color) {
    const div = document.createElement('div');
    div.className = 'function-item active-selection';
    div.dataset.id = id;
    div.style.borderLeftColor = color;
    div.onclick = (e) => selectFunction(id, div, e);
    div.innerHTML = `
        <div class="input-group">
            <div class="f-label" style="color:${color}">f(x)=</div>
            <input type="text" value="${expr}" onkeyup="updateFunction(${id}, this.value)">
        </div>
        <div class="controls">
            <button class="btn-icon" onclick="toggleVisibility(${id}, this)"><i class="fas fa-eye"></i></button>
            <button class="btn-icon danger" onclick="removeFunction(${id})"><i class="fas fa-trash"></i></button>
        </div>
    `;
    
    document.querySelectorAll('.function-item').forEach(el => el.classList.remove('active-selection'));
    
    uiList.appendChild(div);
}

// Global UI Handlers
window.selectFunction = (id, el, e) => {
    if(e.target.tagName === 'BUTTON' || e.target.tagName === 'I') return;
    engine.selectedFuncId = id;
    document.querySelectorAll('.function-item').forEach(d => d.classList.remove('active-selection'));
    el.classList.add('active-selection');
    engine.requestRender();
};

window.updateFunction = (id, newExpr) => {
    const f = engine.functions.find(x => x.id === id);
    if(f) {
        f.expr = newExpr;
        f.func = MathCore.parse(newExpr);
        engine.requestRender();
    }
};

window.toggleVisibility = (id, btn) => {
    const f = engine.functions.find(x => x.id === id);
    if(f) {
        f.visible = !f.visible;
        btn.innerHTML = f.visible ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        btn.style.opacity = f.visible ? 1 : 0.5;
        engine.requestRender();
    }
};

window.removeFunction = (id) => {
    engine.functions = engine.functions.filter(x => x.id !== id);
    document.querySelector(`.function-item[data-id="${id}"]`).remove();
    engine.selectedFuncId = engine.functions.length ? engine.functions[0].id : null;
    engine.requestRender();
};

// Add Default Function
document.getElementById('btnAddFunc').addEventListener('click', () => {
    const color = colors[colorIdx++ % colors.length];
    const expr = 'sin(x) * x';
    const id = engine.addFunction(expr, color);
    createFunctionUI(id, expr, color);
});

// --- TOOLBAR ACTIONS ---

function getActiveFunc() {
    return engine.functions.find(x => x.id === engine.selectedFuncId) || engine.functions[0];
}

function log(title, html) {
    analysisOut.innerHTML = `
        <div style="margin-bottom:12px; border-bottom:1px solid #333; padding-bottom:5px;">
            <b style="color:#fff">${title}</b>
        </div>
        ${html}
    `;
}

document.getElementById('btnHome').onclick = () => {
    engine.camera = { x: 0, y: 0, zoom: 50 };
    engine.overlayFunc = null;
    engine.fillArea = null;
    engine.markers = [];
    engine.requestRender();
    analysisOut.innerHTML = '';
};

document.getElementById('btnSnapshot').onclick = () => engine.exportImage();

document.getElementById('btnTable').onclick = () => {
    const f = getActiveFunc();
    if(!f) return alert("Nincs függvény!");
    
    const modal = document.getElementById('tableModal');
    const tbody = document.querySelector('#dataTableContent tbody');
    tbody.innerHTML = '';
    
    const start = Math.floor(engine.toWorldX(0));
    const end = Math.ceil(engine.toWorldX(engine.width));
    const step = (end - start) / 20;
    
    for(let x = start; x <= end; x += (step || 1)) {
        const y = MathCore.evaluate(f.func, x);
        const row = `<tr><td>${x.toFixed(2)}</td><td style="color:${f.color}">${y.toFixed(4)}</td></tr>`;
        tbody.innerHTML += row;
    }
    modal.style.display = 'flex';
};

document.getElementById('btnRoots').onclick = () => {
    const f = getActiveFunc();
    if(!f) return;
    const roots = MathCore.findRoots(f.func, engine.toWorldX(0), engine.toWorldX(engine.width));
    engine.markers = roots.map(r => ({ x: r, y: 0, color: '#ff7675' }));
    engine.requestRender();
    log('Zérushelyek', roots.map(r => `<div class="result-row"><span class="result-key">x =</span><span class="result-val">${r.toFixed(4)}</span></div>`).join('') || "Nincs zérushely a nézetben.");
};

document.getElementById('btnExtrema').onclick = () => {
    const f = getActiveFunc();
    if(!f) return;
    const ex = MathCore.findExtrema(f.func, engine.toWorldX(0), engine.toWorldX(engine.width));
    engine.markers = ex.map(e => ({ x: e.x, y: e.y, color: '#fdcb6e' }));
    engine.requestRender();
    log('Lokális Szélsőértékek', ex.map(e => `<div class="result-row"><span class="result-key">${e.type}</span><span class="result-val">(${e.x.toFixed(2)}, ${e.y.toFixed(2)})</span></div>`).join('') || "Nincs szélsőérték.");
};

document.getElementById('btnIntersect').onclick = () => {
    const visible = engine.functions.filter(f => f.visible);
    if(visible.length < 2) return alert("Legalább 2 látható függvény szükséges!");
    
    const f1 = visible[0];
    const f2 = visible[1];
    
    const pts = MathCore.findIntersections(f1.func, f2.func, engine.toWorldX(0), engine.toWorldX(engine.width));
    engine.markers = pts.map(p => ({ x: p.x, y: p.y, color: '#fff' }));
    engine.requestRender();
    
    log(`Metszéspontok`, pts.map(p => `<div class="result-row"><span class="result-key">P</span><span class="result-val">(${p.x.toFixed(3)}, ${p.y.toFixed(3)})</span></div>`).join('') || "Nincs metszéspont.");
};

document.getElementById('btnIntegral').onclick = () => {
    const f = getActiveFunc(); if(!f) return;
    const a = parseFloat(prompt("Alsó határ (a):", Math.floor(engine.toWorldX(0))+1));
    const b = parseFloat(prompt("Felső határ (b):", Math.floor(engine.toWorldX(engine.width))-1));
    if(isNaN(a) || isNaN(b)) return;
    
    const area = MathCore.integrate(f.func, a, b);
    engine.fillArea = { func: f.func, a, b, color: f.color };
    engine.requestRender();
    
    log(`Integrál [${a}, ${b}]`, `<div style="font-size:1.5rem; color:${varCSS('--success')}">∫ ≈ ${area.toFixed(5)}</div>`);
};

document.getElementById('btnTangent').onclick = () => {
    const f = getActiveFunc(); if(!f) return;
    const x0 = parseFloat(prompt("Érintési pont (x):", "1"));
    if(isNaN(x0)) return;
    
    const m = MathCore.derivative(f.func, x0);
    engine.markers = [{ x: x0, y: f.func(x0), slope: m, color: '#fff' }];
    engine.requestRender();
    
    log(`Érintő x=${x0}-ban`, `<div class="result-row"><span class="result-key">Meredekség (m):</span><span class="result-val">${m.toFixed(4)}</span></div>`);
};

document.getElementById('btnDerivPlot').onclick = () => {
    const f = getActiveFunc();
    if(!f) return;
    
    if(engine.overlayFunc) {
        engine.overlayFunc = null;
    } else {
        engine.overlayFunc = {
            func: (x) => MathCore.derivative(f.func, x)
        };
    }
    engine.requestRender();
};

document.getElementById('btnAutoFit').onclick = () => engine.autoFocusY();


document.getElementById('btnAddFunc').click();
function varCSS(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

</script>
</body>
</html>
